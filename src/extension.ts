import * as vscode from 'vscode';

import { Position } from "vscode";
import { FullRefactor } from "./refactors/FullRefactor";
import { BLoc, IAction, IAnalysis, IChange } from './refactors/interfaces/IRefactor';
import { AllStyleExtractRefactor, StyleDeclareRefactor } from './refactors';
import { getStyleNameToMove } from './vscode-utils';
import { ReactFile } from './refactors/ReactFile';
import { findAllProblematicStyles } from './refactors/refactor-utils';

export const MOVE_ALL_STYLES_TO_CONSTANT_COMMAND = "react-easy-refactor.move-all-styles-to-constant";
export const RENAME_AUTO_GENERATED_STYLES_COMMAND = "react-easy-refactor.rename-auto-generated-styles";

export function activate(context: vscode.ExtensionContext) {
	// context.subscriptions.push(
	// 	vscode.languages.registerCodeActionsProvider('typescriptreact', new ReactRefactorActionCodeProvider(), {
	// 		providedCodeActionKinds: ReactRefactorActionCodeProvider.providedCodeActionKinds
	// 	}),
	// );

	const styleDiagnostics = vscode.languages.createDiagnosticCollection("inline-styles-collection");
	context.subscriptions.push(styleDiagnostics);

	subscribeToDocumentChanges(context, styleDiagnostics);

	context.subscriptions.push(
		vscode.commands.registerCommand(MOVE_ALL_STYLES_TO_CONSTANT_COMMAND, onUserSelectsMoveAllStylesToConstant)
	);
	context.subscriptions.push(
		vscode.commands.registerCommand(RENAME_AUTO_GENERATED_STYLES_COMMAND, onUserSelectsRenameAutoGeneratedStyles)
	);
	// context.subscriptions.push(
	// 	vscode.commands.registerCommand(COMMAND, () => vscode.env.openExternal(vscode.Uri.parse('https://unicode.org/emoji/charts-12.0/full-emoji-list.html')))
	// );
}

async function onUserSelectsMoveAllStylesToConstant() {
	const editor = vscode.window.activeTextEditor;
	if(!editor){
		return;
	}
	let sourceCode = editor.document.getText();
	let ast  = FullRefactor.parseCodeSafe(sourceCode);
	if(!ast){
		 vscode.window.showErrorMessage("Could not parse file");
		 return;
	}
	const reactFile = new ReactFile(ast);
	const options = reactFile.getPossibleOptionsForStyleDeclaration();
	const result = await getStyleNameToMove(options);
	if(!result ){
		return;
	}
	if(result.isCustom){
		const refactor = new StyleDeclareRefactor(result.name).refactor(ast);
		if(refactor.type !== 'required'){
			return;
		}
		await editor.edit(editBuilder => {
			refactor.changes.forEach((x) => {
				convertRefactorToTextEditorEdit(editBuilder, x);
			});
			return editBuilder;
		});	
		sourceCode = editor.document.getText();
		ast = FullRefactor.parseCodeSafe(sourceCode);
		if(!ast){
			 vscode.window.showErrorMessage("Could not parse file again. Might be a problem in variable creation");
			 return;
		}
	}
	const refactor = new AllStyleExtractRefactor(result.name).refactor(ast);
	if(refactor.type !== 'required'){
		return;
	}
	await editor.edit(editBuilder => {
		refactor.changes.forEach((x) => {
			convertRefactorToTextEditorEdit(editBuilder, x);
		});
		return editBuilder;
	});		
}

const STYLE_NAME_REGEX = /\.style_\d+/g;

export const VALID_VARIABLE_NAME_REGEX = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;

async function onUserSelectsRenameAutoGeneratedStyles() {
	const editor = vscode.window.activeTextEditor;
	if(!editor){
		return;
	}
	let renamed = 0;
	while (true) {
		const sourceCode = editor.document.getText();
		if(!sourceCode.match(STYLE_NAME_REGEX)){
			if(renamed === 0){
				vscode.window.showErrorMessage("No styles found to rename.");
			}
			return;
		}
		const indexOf = sourceCode.search(STYLE_NAME_REGEX);
		if(indexOf === -1){
			return;
		}
		const properIndex= indexOf + 1;
		const styleName = sourceCode.match(STYLE_NAME_REGEX)![0];
		const properIndexEnd = properIndex + styleName.length - 1;
		const styleNameWithoutDot = styleName.substring(1);
		editor.revealRange(new vscode.Range(editor.document.positionAt(properIndex), editor.document.positionAt(properIndexEnd).translate(10, 0)));
		editor.selection = new vscode.Selection(editor.document.positionAt(properIndex), editor.document.positionAt(properIndexEnd));
		const newName = await vscode.window.showInputBox({prompt: `Rename ${styleName} to:`, value: styleNameWithoutDot});
		if(!newName){
			return;
		}
		if(!newName.match(VALID_VARIABLE_NAME_REGEX)){
			vscode.window.showErrorMessage("Invalid name");
			return;
		}
		const result = await executeRename(editor.document.uri, editor.document.positionAt(properIndex), newName);
		if(!result){
			vscode.window.showErrorMessage("Could not rename");
			return;
		}
		renamed++;
	}
}

async function executeRename(uri: vscode.Uri, position: vscode.Position, newName: string):Promise<boolean> {
	try{
		await vscode.commands.executeCommand('vscode.prepareRename', uri, position, newName);
		const edits :vscode.WorkspaceEdit=  await vscode.commands.executeCommand('vscode.executeDocumentRenameProvider', uri, position, newName);
		if(!edits){
			return false;
		}else{
			await vscode.workspace.applyEdit(edits);
		}
		return true;
	}catch(e){
		console.log(e);
		return false;
	}
}

export function convertRefactorToTextEditorEdit(textEditorEdit: vscode.TextEditorEdit, change: IChange): void {
	if(change.type === 'none'){
		return undefined;
	}
	if(change.type === 'delete'){
		textEditorEdit.delete(new vscode.Range(
			mapBLocToVsCodePosition(change.start),
			mapBLocToVsCodePosition(change.end)
		));
	}
	if(change.type === 'insert'){
		textEditorEdit.insert(
			mapBLocToVsCodePosition(change.start),
			change.text
		);
	}
	if(change.type === 'replace'){
		textEditorEdit.replace(
			new vscode.Range(
				mapBLocToVsCodePosition(change.start),
				mapBLocToVsCodePosition(change.end),
			),
			change.text
		);
	}
	if(change.type === 'multiple'){
		change.changes.forEach(c => convertRefactorToTextEditorEdit(textEditorEdit, c));
	}
	return undefined;
}

export function convertRefactorToCodeAction(documentUri: vscode.Uri, change: IChange, fix: vscode.CodeAction): vscode.CodeAction | undefined {
	if (change.type === 'none') {
		return undefined;
	}

	if (!fix.edit) {
		throw new Error('fix.edit is undefined');
	}
	if (change.type === 'delete') {
		fix.edit.delete(documentUri, new vscode.Range(
			mapBLocToVsCodePosition(change.start),
			mapBLocToVsCodePosition(change.end)
		));
	} else if (change.type === 'insert') {
		fix.edit.insert(
			documentUri,
			mapBLocToVsCodePosition(change.start),
			change.text
		);
	} else if (change.type === 'replace') {
		fix.edit.replace(
			documentUri,
			new vscode.Range(
				mapBLocToVsCodePosition(change.start),
				mapBLocToVsCodePosition(change.end),
			),
			change.text
		);
	} else if (change.type === 'multiple') {
		change.changes.forEach(c => convertRefactorToCodeAction(documentUri, c, fix));
	}
	return fix;
}

export function convertIActionRefactorToCodeAction(documentUri: vscode.Uri, action: IAction): vscode.CodeAction | undefined {
	if (action.type == 'none') {
		return undefined;
	}
	const fix = new vscode.CodeAction(action.name, vscode.CodeActionKind.QuickFix);
	fix.edit = new vscode.WorkspaceEdit();

	action.changes.forEach(c => convertRefactorToCodeAction(documentUri, c, fix));
	return fix;
}



// const fullRefactor = new FullRefactor([
// 	new StyleDeclareRefactor(),
// 	new AllStyleExtractRefactor(),
// ]);

// export class ReactRefactorActionCodeProvider implements vscode.CodeActionProvider {

// 	public static readonly providedCodeActionKinds = [
// 		vscode.CodeActionKind.QuickFix
// 	];

// 	public provideCodeActions(document: vscode.TextDocument, range: vscode.Range): vscode.CodeAction[] | undefined {
// 		const sourceCode = document.getText();
// 		const refactors = fullRefactor.refactor(sourceCode);
// 		return refactors
// 			.map(refactor => convertIActionRefactorToCodeAction(document.uri, refactor))
// 			.filter((x): x is vscode.CodeAction => x !== undefined)
// 			.map(x => {
// 				return x;
// 			});
// 	}

// }

export function mapBLocToVsCodePosition(location: BLoc): vscode.Position {
	return new Position(location.line - 1, location.column);
}

export function mapIAnalysisSeverityToVsCodeSeverity(severity: IAnalysis['severity']): vscode.DiagnosticSeverity {
	switch (severity) {
		case 'error': return vscode.DiagnosticSeverity.Error;
		case 'warning': return vscode.DiagnosticSeverity.Warning;
		case 'info': return vscode.DiagnosticSeverity.Information;
		case 'hint': return vscode.DiagnosticSeverity.Hint;
	}
}

export function refreshDiagnostics(doc: vscode.TextDocument, styleDiagnostics: vscode.DiagnosticCollection): void {
	const diagnostics: vscode.Diagnostic[] = [];
	const sourceCode = doc.getText();
	const ast = FullRefactor.parseCodeSafe(sourceCode);
	if(!ast){
		styleDiagnostics.set(doc.uri, diagnostics);

	}else{
		const styles = findAllProblematicStyles(ast);
		
		styles
		.filter((x) => !!x.loc)
		.forEach(x => {
			const object = x.value.expression;
			if(!object.loc) {
				return;
			}
			diagnostics.push(new vscode.Diagnostic(
				new vscode.Range(
					mapBLocToVsCodePosition(object.loc.start),
					mapBLocToVsCodePosition(object.loc.end),
				),
				'Movable Style Declaration',
				mapIAnalysisSeverityToVsCodeSeverity('info'),
			));
		});
	}
	styleDiagnostics.set(doc.uri, diagnostics);
}


export function subscribeToDocumentChanges(context: vscode.ExtensionContext, styleDiagnostics: vscode.DiagnosticCollection): void {
	if (vscode.window.activeTextEditor) {
		refreshDiagnostics(vscode.window.activeTextEditor.document, styleDiagnostics);
	}
	context.subscriptions.push(
		vscode.window.onDidChangeActiveTextEditor(editor => {
			if (editor) {
				refreshDiagnostics(editor.document, styleDiagnostics);
			}
		})
	);

	context.subscriptions.push(
		vscode.workspace.onDidChangeTextDocument(e => refreshDiagnostics(e.document, styleDiagnostics))
	);

	context.subscriptions.push(
		vscode.workspace.onDidCloseTextDocument(doc => styleDiagnostics.delete(doc.uri))
	);
}


// export function activate(context: vscode.ExtensionContext) {

// 	// Use the console to output diagnostic information (console.log) and errors (console.error)
// 	// This line of code will only be executed once when your extension is activated
// 	console.log('Congratulations, your extension "react-easy-refactor" is now active!');

// 	// The command has been defined in the package.json file
// 	// Now provide the implementation of the command with registerCommand
// 	// The commandId parameter must match the command field in package.json
// 	let disposable = vscode.commands.registerCommand('react-easy-refactor.helloWorld', () => {
// 		// The code you place here will be executed every time your command is executed
// 		// Display a message box to the user
// 		vscode.window.showInformationMessage('Hello World from react-easy-refactor!');
// 	});

// 	context.subscriptions.push(disposable);
// }

// // This method is called when your extension is deactivated
// export function deactivate() { }
